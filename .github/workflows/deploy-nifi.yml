name: Deploy NiFi (Reusable)

on:

  workflow_call:
    inputs:
      environment:
        required: true
        type: string
        description: 'Target environment (development, staging, production)'
      force_restart:
        required: false
        type: boolean
        default: false
      deploy_flows:
        required: false
        type: boolean
        default: false
      restart_services:
        required: false
        type: boolean
        default: false
      rollback_tag:
        required: false
        type: string
        description: 'Tag to rollback to (production only)'
      skip_release:
        required: false
        type: boolean
        default: false
    outputs:
      deployment_successful:
        description: 'Whether deployment succeeded'
        value: ${{ jobs.deploy.outputs.success }}
      release_tag:
        description: 'Release tag created (production only)'
        value: ${{ jobs.create-release.outputs.tag_name }}

permissions:
  contents: write
  actions: read

jobs:

  get-config:
    name: Get Config & Detect Changes
    runs-on: ubuntu-22.04
    outputs:
      resource_group: ${{ steps.config.outputs.resource_group }}
      vm_name: ${{ steps.config.outputs.vm_name }}
      compose_file: ${{ steps.config.outputs.compose_file }}
      container_suffix: ${{ steps.config.outputs.container_suffix }}
      backup_dir: ${{ steps.config.outputs.backup_dir }}
      registry_changed: ${{ steps.changes.outputs.registry_changed }}
      nifi_changed: ${{ steps.changes.outputs.nifi_changed }}
      flows_only: ${{ steps.changes.outputs.flows_only }}
      should_restart: ${{ steps.changes.outputs.should_restart }}
    steps:
      
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 2
          ref: ${{ inputs.rollback_tag || github.ref }}

      - name: Set Environment Configuration
        id: config
        run: |
          ENV="${{ inputs.environment }}"
          RG_SUFFIX="${ENV/development/dev}"
          
          echo "resource_group=rg-nificicd-g1p2-$RG_SUFFIX" >> $GITHUB_OUTPUT
          echo "vm_name=vm-nifi-$ENV" >> $GITHUB_OUTPUT
          echo "container_suffix=$RG_SUFFIX" >> $GITHUB_OUTPUT
          echo "backup_dir=$ENV" >> $GITHUB_OUTPUT
          echo "compose_file=compose.$ENV.yml" >> $GITHUB_OUTPUT
          
      - name: Analyze Changes
        id: changes
        run: |
          # Rollback mode - restart everything
          if [ -n "${{ inputs.rollback_tag }}" ]; then
            echo "registry_changed=true" >> $GITHUB_OUTPUT
            echo "nifi_changed=true" >> $GITHUB_OUTPUT
            echo "flows_only=false" >> $GITHUB_OUTPUT
            echo "should_restart=true" >> $GITHUB_OUTPUT
            echo "Rollback mode - will restart all services"
            exit 0
          fi
          
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD 2>/dev/null || echo "")
          
          echo "Changed files:"
          echo "$CHANGED_FILES" | while read f; do [ -n "$f" ] && echo "  - $f"; done
          
          # Detect changes
          FLOWS_ONLY=false
          if echo "$CHANGED_FILES" | grep -q 'flows/' && \
             ! echo "$CHANGED_FILES" | grep -qE '(config/|scripts/|compose\.|registry_data/)'; then
            FLOWS_ONLY=true
          fi
          
          REGISTRY_CHANGED=$(echo "$CHANGED_FILES" | grep -qE '(registry_data/|config/bootstrap-additions\.conf)' && echo true || echo false)
          NIFI_CHANGED=$(echo "$CHANGED_FILES" | grep -qE '(config/|scripts/|compose\.)' && ! echo "$CHANGED_FILES" | grep -q 'registry_data/' && echo true || echo false)
          
          # Determine restart need
          SHOULD_RESTART=false
          [ "${{ inputs.force_restart }}" = "true" ] || [ "${{ inputs.restart_services }}" = "true" ] && SHOULD_RESTART=true
          [ "$REGISTRY_CHANGED" = "true" ] || [ "$NIFI_CHANGED" = "true" ] && SHOULD_RESTART=true
          [ "$FLOWS_ONLY" = "true" ] && SHOULD_RESTART=false
          
          echo "registry_changed=$REGISTRY_CHANGED" >> $GITHUB_OUTPUT
          echo "nifi_changed=$NIFI_CHANGED" >> $GITHUB_OUTPUT
          echo "flows_only=$FLOWS_ONLY" >> $GITHUB_OUTPUT
          echo "should_restart=$SHOULD_RESTART" >> $GITHUB_OUTPUT
          
          echo "Registry: $REGISTRY_CHANGED | NiFi: $NIFI_CHANGED | Flows only: $FLOWS_ONLY | Restart: $SHOULD_RESTART"

  validate-and-check:
    name: Validate & Check Infrastructure
    runs-on: ubuntu-22.04
    needs: get-config
    environment: ${{ inputs.environment }}
    outputs:
      vm_ip: ${{ steps.get_ip.outputs.ip }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ inputs.rollback_tag || github.ref }}
        
      - name: Verify Secrets
        run: |
          MISSING=()
          [ -z "${{ secrets.VM_PUBLIC_IP }}" ] && MISSING+=("VM_PUBLIC_IP")
          [ -z "${{ secrets.VM_USERNAME }}" ] && MISSING+=("VM_USERNAME")
          [ -z "${{ secrets.NIFI_USERNAME }}" ] && MISSING+=("NIFI_USERNAME")
          [ -z "${{ secrets.NIFI_PASSWORD }}" ] && MISSING+=("NIFI_PASSWORD")
          [ -z "${{ secrets.NIFI_SENSITIVE_PROPS_KEY }}" ] && MISSING+=("NIFI_SENSITIVE_PROPS_KEY")
          [ -z "${{ secrets.NIFI_WEB_PROXY_HOST }}" ] && MISSING+=("NIFI_WEB_PROXY_HOST")
          
          [ ${#MISSING[@]} -gt 0 ] && echo "Missing secrets: ${MISSING[*]}" && echo "Run 'Provision Infrastructure' first" && exit 1
          echo "All secrets verified"
        
      - name: Validate Compose File
        run: |
          cat > .env.${{ inputs.environment }} <<EOF
          NIFI_USERNAME=${{ secrets.NIFI_USERNAME }}
          NIFI_PASSWORD=${{ secrets.NIFI_PASSWORD }}
          NIFI_SENSITIVE_PROPS_KEY=${{ secrets.NIFI_SENSITIVE_PROPS_KEY }}
          VM_PUBLIC_IP=${{ secrets.VM_PUBLIC_IP }}
          NIFI_WEB_PROXY_HOST=${{ secrets.NIFI_WEB_PROXY_HOST }}
          NIFI_HTTPS_PORT=${{ secrets.NIFI_HTTPS_PORT }}
          NIFI_REGISTRY_PORT=${{ secrets.NIFI_REGISTRY_PORT }}
          EOF
          
          docker compose -f ${{ needs.get-config.outputs.compose_file }} config --quiet
          echo "Compose file validated"
          rm -f .env.${{ inputs.environment }}

      - name: Azure Login and Verify VM
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.ARM_CLIENT_ID }}",
              "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.ARM_TENANT_ID }}"
            }
            
      - name: Get VM IP
        id: get_ip
        run: |
          VM_IP=$(az vm show \
            --resource-group ${{ needs.get-config.outputs.resource_group }} \
            --name ${{ needs.get-config.outputs.vm_name }} \
            --show-details --query publicIps -o tsv 2>/dev/null || echo "")
          
          [ -z "$VM_IP" ] && echo "ERROR: VM not found" && exit 1
          echo "ip=$VM_IP" >> $GITHUB_OUTPUT
          echo "VM found: $VM_IP"

  create-release:
    name: Create Release Tag
    runs-on: ubuntu-22.04
    needs: validate-and-check
    if: inputs.environment == 'production' && inputs.skip_release != true && inputs.rollback_tag == ''
    outputs:
      tag_name: ${{ steps.tag.outputs.tag_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_TOKEN }}

      - name: Generate and Push Version Tag
        id: tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          LATEST=$(git tag -l "v*.*.*" --sort=-version:refname | head -1)
          
          if [ -z "$LATEST" ]; then
            NEW_TAG="v1.0.0"
          else
            VERSION=${LATEST#v}
            IFS='.' read -r MAJ MIN PATCH <<< "$VERSION"
            NEW_TAG="v${MAJ}.${MIN}.$((PATCH + 1))"
          fi
          
          git tag -a "$NEW_TAG" -m "Production release $NEW_TAG - Run #${{ github.run_number }}"
          git push origin "$NEW_TAG"
          
          echo "tag_name=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "âœ… Created tag: $NEW_TAG"

  deploy:
    name: Deploy to ${{ inputs.environment }}
    needs: [get-config, validate-and-check, create-release]
    if: always() && needs.validate-and-check.result == 'success'
    runs-on: ubuntu-22.04
    environment: ${{ inputs.environment }}
    outputs:
      success: ${{ steps.status.outputs.success }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ inputs.rollback_tag || github.ref }}

      - name: Setup SSH and Test Connection
        run: |
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          VM_IP="${{ needs.validate-and-check.outputs.vm_ip }}"
          VM_USER="${{ secrets.VM_USERNAME }}"
          
          ssh-keyscan -H $VM_IP >> ~/.ssh/known_hosts 2>/dev/null || true
          
          echo "Testing SSH connection..."
          for i in {1..5}; do
            if ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
              $VM_USER@$VM_IP "echo 'SSH connected'"; then
              echo "SSH connected"
              exit 0
            fi
            echo "Attempt $i/5 failed..."
            [ $i -lt 5 ] && sleep $((i * 30))
          done
          echo "ERROR: SSH connection failed"
          exit 1

      - name: Pre-Deployment Backup
        if: needs.get-config.outputs.should_restart == 'true'
        run: |
          VM_IP="${{ needs.validate-and-check.outputs.vm_ip }}"
          VM_USER="${{ secrets.VM_USERNAME }}"
          BACKUP_DIR="${{ needs.get-config.outputs.backup_dir }}"
          COMPOSE_FILE="${{ needs.get-config.outputs.compose_file }}"
          
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            $VM_USER@$VM_IP "bash -s" <<EOF
          [ ! -d ~/nificicd-g1p2 ] && echo "First deployment - no backup needed" && exit 0
          
          BACKUP=~/backups/$BACKUP_DIR/\$(date +%Y%m%d_%H%M%S)
          mkdir -p "\$BACKUP"
          
          cd ~/nificicd-g1p2
          for item in flows config $COMPOSE_FILE; do
            [ -e "\$item" ] && cp -r "\$item" "\$BACKUP/" && echo "Backed up \$item"
          done
          
          # Keep last 5 backups
          cd ~/backups/$BACKUP_DIR
          ls -t | tail -n +6 | xargs -I {} rm -rf {} 2>/dev/null || true
          echo "Backup: \$BACKUP"
          EOF

      - name: Fix Permissions and Sync Files
        run: |
          VM_IP="${{ needs.validate-and-check.outputs.vm_ip }}"
          VM_USER="${{ secrets.VM_USERNAME }}"
          
          # Fix permissions
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            $VM_USER@$VM_IP "cd ~/nificicd-g1p2 && \
              sudo chown -R \$(whoami):\$(whoami) registry_data/ flows/ 2>/dev/null || true && \
              chmod -R u+rwX registry_data/ flows/ 2>/dev/null || true"
          
          # Sync files
          sudo apt-get update -qq && sudo apt-get install -y rsync
          
          DEPLOY_FLOWS="${{ inputs.deploy_flows }}"
          FLOWS_ONLY="${{ needs.get-config.outputs.flows_only }}"
          [ -n "${{ inputs.rollback_tag }}" ] && DEPLOY_FLOWS=true
          
          EXCLUDE="--exclude=.git/ --exclude=.github/ --exclude=azure-vm-terraform/ --exclude=node_modules/ --exclude=*.log --exclude=.terraform/ --exclude=*.tfstate* --exclude=.env* --exclude=data/"
          [ "$DEPLOY_FLOWS" = "false" ] && [ "$FLOWS_ONLY" = "false" ] && EXCLUDE="$EXCLUDE --exclude=flows/"
          
          echo "Syncing files..."
          rsync -avz $EXCLUDE \
            -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null" \
            ./ $VM_USER@$VM_IP:~/nificicd-g1p2/
          
          echo "Files synced"

      - name: Deploy and Health Check Services
        run: |
          VM_IP="${{ needs.validate-and-check.outputs.vm_ip }}"
          VM_USER="${{ secrets.VM_USERNAME }}"
          COMPOSE_FILE="${{ needs.get-config.outputs.compose_file }}"
          
          SHOULD_RESTART="${{ needs.get-config.outputs.should_restart }}"
          REG_CHG="${{ needs.get-config.outputs.registry_changed }}"
          NIFI_CHG="${{ needs.get-config.outputs.nifi_changed }}"
          [ -n "${{ inputs.rollback_tag }}" ] && SHOULD_RESTART=true REG_CHG=true NIFI_CHG=true
          
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            $VM_USER@$VM_IP \
            "export SHOULD_RESTART='$SHOULD_RESTART' REGISTRY_CHANGED='$REG_CHG' NIFI_CHANGED='$NIFI_CHG' \
             COMPOSE_FILE='$COMPOSE_FILE' \
             NIFI_REGISTRY_PORT='${{ secrets.NIFI_REGISTRY_PORT }}' \
             NIFI_HTTPS_PORT='${{ secrets.NIFI_HTTPS_PORT }}' \
             NIFI_USERNAME='${{ secrets.NIFI_USERNAME }}' \
             NIFI_PASSWORD='${{ secrets.NIFI_PASSWORD }}' \
             NIFI_WEB_PROXY_HOST='${{ secrets.NIFI_WEB_PROXY_HOST }}' \
             NIFI_SENSITIVE_PROPS_KEY='${{ secrets.NIFI_SENSITIVE_PROPS_KEY }}' && bash -s" <<'EOF'
          set -e
          cd ~/nificicd-g1p2
          
          # Deploy services
          if ! sudo docker compose -f "$COMPOSE_FILE" ps 2>/dev/null | grep -q "nifi"; then
            echo "Initial deployment"
            sudo docker pull apache/nifi:2.6.0
            sudo docker pull apache/nifi-registry:2.6.0
            sudo -E docker compose -f "$COMPOSE_FILE" up -d
            sleep 30
          elif [ "$SHOULD_RESTART" = "false" ]; then
            echo "Files synced - no restart needed"
            exit 0
          elif [ "$REGISTRY_CHANGED" = "true" ] && [ "$NIFI_CHANGED" = "false" ]; then
            echo "Restarting Registry..."
            sudo docker compose -f "$COMPOSE_FILE" restart nifi-registry
            sleep 30
          elif [ "$NIFI_CHANGED" = "true" ] && [ "$REGISTRY_CHANGED" = "false" ]; then
            echo "Restarting NiFi..."
            sudo docker compose -f "$COMPOSE_FILE" restart nifi
            sleep 30
          else
            echo "Restarting both services..."
            sudo docker compose -f "$COMPOSE_FILE" restart
            sleep 30
          fi
          
          sudo docker compose -f "$COMPOSE_FILE" ps
          
          # Health checks (only if restarted)
          [ "$SHOULD_RESTART" = "false" ] && exit 0
          
          check_health() {
            local url=$1 max=$2
            for i in $(seq 1 $max); do
              HTTP=$(curl -k -s -o /dev/null -w "%{http_code}" $url 2>/dev/null || echo "000")
              [[ "$HTTP" =~ ^(200|301|302)$ ]] && echo "$url responding (HTTP $HTTP)" && return 0
              [ $((i % 6)) -eq 0 ] && echo "  Waiting... ($i/$max)"
              sleep 10
            done
            echo "ERROR: $url timeout" && return 1
          }
          
          [ "$REGISTRY_CHANGED" = "true" ] && check_health "http://localhost:18080/nifi-registry" 60
          [ "$NIFI_CHANGED" = "true" ] && check_health "https://localhost:8443/nifi" 90
          echo "All health checks passed"
          EOF

      - name: Record Production Deployment
        if: success() && inputs.environment == 'production'
        run: |
          VM_IP="${{ needs.validate-and-check.outputs.vm_ip }}"
          VM_USER="${{ secrets.VM_USERNAME }}"
          TAG="${{ needs.create-release.outputs.tag_name }}"
          ROLLBACK="${{ inputs.rollback_tag }}"
          
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            $VM_USER@$VM_IP "cd ~/nificicd-g1p2 && \
              echo \"[\$(date -u +%Y-%m-%d\ %H:%M:%S)] \$([ -n '$ROLLBACK' ] && echo 'ROLLBACK to $ROLLBACK' || echo 'DEPLOY $TAG') - Run #${{ github.run_number }}\" >> deployments.log && \
              tail -50 deployments.log > deployments.log.tmp && mv deployments.log.tmp deployments.log"

      - name: Set Status and Cleanup
        id: status
        if: always()
        run: |
          echo "success=${{ job.status == 'success' }}" >> $GITHUB_OUTPUT
          rm -f ~/.ssh/deploy_key

      - name: Summary
        if: success()
        run: |
          cat <<SUMMARY
          
          ${{ inputs.environment }} DEPLOYMENT SUCCESSFUL
          
          $([ -n "${{ inputs.rollback_tag }}" ] && echo "Rollback: ${{ inputs.rollback_tag }}")
          $([ -n "${{ needs.create-release.outputs.tag_name }}" ] && echo "Release: ${{ needs.create-release.outputs.tag_name }}")
          NiFi:     ${{ secrets.NIFI_URL }}
          Registry: ${{ secrets.REGISTRY_URL }}
          
          SUMMARY