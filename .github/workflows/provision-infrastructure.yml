name: Provision Infrastructure

on:

  workflow_dispatch:
    inputs:
      environments:
        description: 'Environment(s) to provision (comma-separated: development,staging,production or select multiple)'
        required: true
        type: string
        default: 'development'
      force_recreate:
        description: 'Force recreate if infrastructure exists?'
        required: false
        type: boolean
        default: false
      wait_time:
        description: 'Wait time between environments (seconds)'
        required: false
        type: number
        default: 60

permissions:
  contents: read
  actions: read

jobs:

  determine-environments:
    name: Determine Target Environments
    runs-on: ubuntu-22.04
    outputs:
      environments: ${{ steps.set_envs.outputs.environments }}
      environment_list: ${{ steps.set_envs.outputs.environment_list }}
      is_multiple: ${{ steps.set_envs.outputs.is_multiple }}
    steps:
      - name: Parse and Validate Environments
        id: set_envs
        run: |
          # Get input and clean it up
          INPUT="${{ github.event.inputs.environments }}"
          
          # Remove spaces and convert to lowercase
          INPUT=$(echo "$INPUT" | tr -d ' ' | tr '[:upper:]' '[:lower:]')
          
          # Split by comma and validate
          IFS=',' read -ra ENV_ARRAY <<< "$INPUT"
          
          VALID_ENVS=()
          INVALID_ENVS=()
          
          for env in "${ENV_ARRAY[@]}"; do
            case "$env" in
              development|staging|production)
                # Check for duplicates
                if [[ ! " ${VALID_ENVS[@]} " =~ " ${env} " ]]; then
                  VALID_ENVS+=("$env")
                fi
                ;;
              *)
                INVALID_ENVS+=("$env")
                ;;
            esac
          done
          
          # Report invalid environments
          if [ ${#INVALID_ENVS[@]} -gt 0 ]; then
            echo "Invalid environment(s) specified: ${INVALID_ENVS[*]}"
            echo ""
            echo "Valid options: development, staging, production"
            exit 1
          fi
          
          # Check if any valid environments found
          if [ ${#VALID_ENVS[@]} -eq 0 ]; then
            echo "No valid environments specified"
            echo ""
            echo "Valid options: development, staging, production"
            exit 1
          fi
          
          # Build JSON array for matrix
          JSON_ARRAY="["
          for i in "${!VALID_ENVS[@]}"; do
            if [ $i -gt 0 ]; then
              JSON_ARRAY+=","
            fi
            JSON_ARRAY+="\"${VALID_ENVS[$i]}\""
          done
          JSON_ARRAY+="]"
          
          # Build comma-separated list
          ENV_LIST=$(IFS=','; echo "${VALID_ENVS[*]}")
          
          # Determine if multiple environments
          if [ ${#VALID_ENVS[@]} -gt 1 ]; then
            IS_MULTIPLE="true"
            echo "ðŸŒ Provisioning ${#VALID_ENVS[@]} environments: $ENV_LIST"
          else
            IS_MULTIPLE="false"
            echo "ðŸŽ¯ Provisioning: ${VALID_ENVS[0]}"
          fi
          
          echo "environments=$JSON_ARRAY" >> $GITHUB_OUTPUT
          echo "environment_list=$ENV_LIST" >> $GITHUB_OUTPUT
          echo "is_multiple=$IS_MULTIPLE" >> $GITHUB_OUTPUT
          
          echo ""
          echo "Validated environments:"
          for env in "${VALID_ENVS[@]}"; do
            echo "  âœ“ $env"
          done

  check-infrastructure:
    name: Check Infrastructure (${{ matrix.environment }})
    needs: determine-environments
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        environment: ${{ fromJson(needs.determine-environments.outputs.environments) }}
      fail-fast: false
    environment: ${{ matrix.environment }}
    outputs:
      infra_exists_dev: ${{ steps.check_infra.outputs.exists_dev }}
      infra_exists_staging: ${{ steps.check_infra.outputs.exists_staging }}
      infra_exists_prod: ${{ steps.check_infra.outputs.exists_prod }}
      vm_ip_dev: ${{ steps.check_infra.outputs.ip_dev }}
      vm_ip_staging: ${{ steps.check_infra.outputs.ip_staging }}
      vm_ip_prod: ${{ steps.check_infra.outputs.ip_prod }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        
      - name: Set Environment Variables
        id: set_env
        run: |
          ENV="${{ matrix.environment }}"
          case $ENV in
            development)
              echo "rg=rg-nifi-cicd-dev" >> $GITHUB_OUTPUT
              echo "vm_name=vm-nifi-development" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "rg=rg-nifi-cicd-staging" >> $GITHUB_OUTPUT
              echo "vm_name=vm-nifi-staging" >> $GITHUB_OUTPUT
              ;;
            production)
              echo "rg=rg-nifi-cicd-prod" >> $GITHUB_OUTPUT
              echo "vm_name=vm-nifi-production" >> $GITHUB_OUTPUT
              ;;
          esac
          
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.ARM_CLIENT_ID }}",
              "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.ARM_TENANT_ID }}"
            }
            
      - name: Check if Infrastructure Exists
        id: check_infra
        run: |
          RG="${{ steps.set_env.outputs.rg }}"
          VM_NAME="${{ steps.set_env.outputs.vm_name }}"
          ENV="${{ matrix.environment }}"
          
          echo "Checking if $ENV infrastructure exists..."
          echo "Resource Group: $RG"
          echo "VM Name: $VM_NAME"
          
          EXISTS="false"
          VM_IP=""
          
          if az group exists --name $RG | grep -q "true"; then
            echo "âœ“ Resource group exists"
            
            VM_EXISTS=$(az vm show --resource-group $RG --name $VM_NAME 2>/dev/null || echo "NOT_FOUND")
            
            if [ "$VM_EXISTS" != "NOT_FOUND" ]; then
              echo "âœ“ VM exists"
              
              VM_IP=$(az vm show -d --resource-group $RG --name $VM_NAME --query publicIps -o tsv)
              echo "âœ“ VM IP: $VM_IP"
              
              EXISTS="true"
              
              if [ "${{ github.event.inputs.force_recreate }}" = "true" ]; then
                echo ""
                echo "âš ï¸ FORCE RECREATE REQUESTED"
                echo "Will delete and recreate infrastructure"
              else
                echo ""
                echo "==============================="
                echo " INFRASTRUCTURE ALREADY EXISTS "
                echo "==============================="
                echo " Environment: $ENV             "
                echo " VM IP: $VM_IP                 "
                echo "==============================="
              fi
            fi
          fi
          
          # Set outputs with environment suffix
          echo "exists_${ENV}=${EXISTS}" >> $GITHUB_OUTPUT
          echo "ip_${ENV}=${VM_IP}" >> $GITHUB_OUTPUT
          echo "rg_${ENV}=${RG}" >> $GITHUB_OUTPUT
          echo "vm_name_${ENV}=${VM_NAME}" >> $GITHUB_OUTPUT
          
          # Also set generic outputs for this matrix job
          echo "exists=${EXISTS}" >> $GITHUB_OUTPUT
          echo "ip=${VM_IP}" >> $GITHUB_OUTPUT
          echo "rg=${RG}" >> $GITHUB_OUTPUT
          echo "vm_name=${VM_NAME}" >> $GITHUB_OUTPUT

  destroy-existing:
    name: Destroy Existing (${{ matrix.environment }})
    needs: [determine-environments, check-infrastructure]
    if: github.event.inputs.force_recreate == 'true'
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        environment: ${{ fromJson(needs.determine-environments.outputs.environments) }}
      fail-fast: false
    environment: ${{ matrix.environment }}
    steps:
      - name: Get Infrastructure Info
        id: get_info
        run: |
          ENV="${{ matrix.environment }}"
          case $ENV in
            development)
              echo "rg=rg-nifi-cicd-dev" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "rg=rg-nifi-cicd-staging" >> $GITHUB_OUTPUT
              ;;
            production)
              echo "rg=rg-nifi-cicd-prod" >> $GITHUB_OUTPUT
              ;;
          esac
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.ARM_CLIENT_ID }}",
              "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.ARM_TENANT_ID }}"
            }
            
      - name: Delete Resource Group
        run: |
          RG="${{ steps.get_info.outputs.rg }}"
          
          if az group exists --name $RG | grep -q "true"; then
            echo "Deleting resource group: $RG"
            az group delete --name $RG --yes --no-wait
            
            echo "Waiting for deletion to complete..."
            for i in {1..30}; do
              if ! az group exists --name $RG | grep -q "true"; then
                echo "Resource group deleted"
                exit 0
              fi
              echo "Waiting... ($i/30)"
              sleep 10
            done
            
            echo "Deletion still in progress - continuing anyway"
          else
            echo "Resource group does not exist - nothing to delete"
          fi

  setup-secrets:
    name: Setup Secrets (${{ matrix.environment }})
    needs: [determine-environments, check-infrastructure, destroy-existing]
    if: always() && needs.determine-environments.result == 'success'
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        environment: ${{ fromJson(needs.determine-environments.outputs.environments) }}
      fail-fast: false
    environment: ${{ matrix.environment }}
    steps:     
      - name: Checkout code
        uses: actions/checkout@v5
        
      - name: Check and Generate SSH Keys
        id: ssh_keys
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          ENV="${{ matrix.environment }}"
          echo "Checking SSH key configuration for $ENV environment..."
          
          if [ -n "${{ secrets.SSH_PUBLIC_KEY }}" ] && [ -n "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            KEY="${{ secrets.SSH_PUBLIC_KEY }}"
            if [[ "$KEY" =~ ^(ssh-rsa|ssh-ed25519|ecdsa-sha2-nistp256) ]]; then
              echo "SSH keys already configured in $ENV environment"
              echo "generated=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          echo "Generating new SSH key pair for $ENV..."
          
          if [ -z "$GH_TOKEN" ]; then
            echo "ERROR: GH_TOKEN is required!"
            exit 1
          fi
          
          if ! gh auth status 2>&1 | grep -q "Logged in"; then
            echo "GitHub CLI authentication failed"
            exit 1
          fi
          
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keygen -t rsa -b 4096 -f ~/.ssh/nifi_deploy_key_${ENV} -N "" -C "github-actions-nifi-${ENV}"
          
          PUBLIC_KEY=$(cat ~/.ssh/nifi_deploy_key_${ENV}.pub)
          PRIVATE_KEY=$(cat ~/.ssh/nifi_deploy_key_${ENV})
          
          echo "SSH keys generated for $ENV"
          
          echo "$PUBLIC_KEY" | gh secret set SSH_PUBLIC_KEY --env $ENV
          echo "$PRIVATE_KEY" | gh secret set SSH_PRIVATE_KEY --env $ENV
          
          echo "SSH keys saved to $ENV environment secrets"
          echo "generated=true" >> $GITHUB_OUTPUT

      - name: Setup Environment-Specific Secrets
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          ENV="${{ matrix.environment }}"
          echo "Setting up $ENV environment-specific secrets..."
          
          set_secret_if_missing() {
            local name=$1
            local value=$2
            echo "$value" | gh secret set "$name" --env $ENV 2>/dev/null
            echo "âœ“ $name configured"
          }
          
          # VM Configuration
          set_secret_if_missing "VM_USERNAME" "azureuser"
          set_secret_if_missing "VM_SSH_PORT" "22"
          
          # NiFi Configuration
          set_secret_if_missing "NIFI_USERNAME" "admin"
          
          # Generate passwords if not set
          if [ -z "${{ secrets.NIFI_PASSWORD }}" ]; then
            NIFI_PWD=$(openssl rand -hex 16)
            set_secret_if_missing "NIFI_PASSWORD" "$NIFI_PWD"
            echo "NIFI_PASSWORD auto-generated for $ENV"
          fi
          
          if [ -z "${{ secrets.NIFI_SENSITIVE_KEY }}" ]; then
            NIFI_KEY=$(openssl rand -hex 12)
            set_secret_if_missing "NIFI_SENSITIVE_KEY" "$NIFI_KEY"
          fi
          
          # Environment-specific port configuration
          set_secret_if_missing "NIFI_HTTPS_PORT" "8443"
          set_secret_if_missing "NIFI_REGISTRY_PORT" "18080"
          set_secret_if_missing "NIFI_WEB_HTTPS_HOST" "0.0.0.0"
          set_secret_if_missing "NIFI_ELECTION_MAX_WAIT" "1 min"
          set_secret_if_missing "NIFI_REGISTRY_HOST" "0.0.0.0"
          
          echo ""
          echo "All $ENV environment secrets configured"

  # ========================================================================
  # SEQUENTIAL PROVISIONING JOBS
  # ========================================================================

  provision-development:
    name: Provision VM (development)
    needs: [determine-environments, check-infrastructure, setup-secrets]
    if: |
      always() &&
      needs.determine-environments.result == 'success' &&
      needs.setup-secrets.result == 'success' &&
      contains(fromJson(needs.determine-environments.outputs.environments), 'development')
    runs-on: ubuntu-22.04
    environment: development
    outputs:
      success: ${{ steps.provision_status.outputs.success }}
      vm_ip: ${{ steps.get_ip.outputs.ip }}
    steps:      
      - name: Checkout code
        uses: actions/checkout@v5
        
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.ARM_CLIENT_ID }}",
              "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.ARM_TENANT_ID }}"
            }
            
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~> 1.5"
          terraform_wrapper: false
          
      - name: Terraform Init
        working-directory: ./azure-vm-terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        run: terraform init -input=false
        
      - name: Terraform Validate
        working-directory: ./azure-vm-terraform
        run: terraform validate
        
      - name: Terraform Plan
        working-directory: ./azure-vm-terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          TF_VAR_environment: development
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_azure_subscription_id: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        run: terraform plan -var-file="development.tfvars" -out=tfplan -input=false
        
      - name: Terraform Apply
        working-directory: ./azure-vm-terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          TF_VAR_environment: development
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_azure_subscription_id: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        run: terraform apply -auto-approve tfplan
        
      - name: Get VM IP Address
        id: get_ip
        working-directory: ./azure-vm-terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        run: |
          VM_IP=$(terraform output -raw vm_public_ip)
          echo "ip=$VM_IP" >> $GITHUB_OUTPUT
          echo "VM Public IP: $VM_IP"
          
      - name: Wait for VM to be ready
        run: |
          echo "Waiting for VM to complete initialization..."
          sleep 45
          echo "VM should be ready"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ steps.get_ip.outputs.ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          
      - name: Configure Docker Permissions
        run: |
          echo "Configuring Docker permissions for user..."
          
          MAX_RETRIES=5
          for i in $(seq 1 $MAX_RETRIES); do
            if ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 \
              ${{ secrets.VM_USERNAME }}@${{ steps.get_ip.outputs.ip }} \
              "sudo usermod -aG docker ${{ secrets.VM_USERNAME }}"; then
              echo "User added to docker group"
              break
            fi
            
            if [ $i -eq $MAX_RETRIES ]; then
              echo "Warning: Failed to configure docker permissions"
            else
              echo "Retry $i/$MAX_RETRIES..."
              sleep 10
            fi
          done
          
          echo ""
          echo "Docker group membership will take effect on next SSH login"
          
      - name: Cleanup SSH Keys
        if: always()
        run: rm -f ~/.ssh/deploy_key

      - name: Update IP-based Secrets
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          ENV="development"
          VM_IP="${{ steps.get_ip.outputs.ip }}"
          
          echo "Updating dynamic secrets for $ENV with VM IP: $VM_IP"
          
          # Verify GH_TOKEN is set
          if [ -z "$GH_TOKEN" ]; then
            echo "ERROR: GH_TOKEN is not set"
            echo "Please ensure GH_TOKEN is configured in repository secrets"
            exit 1
          fi
          
          # Verify GitHub CLI authentication
          if ! gh auth status 2>&1 | grep -q "Logged in"; then
            echo "ERROR: GitHub CLI authentication failed"
            echo "Token may be invalid or expired"
            exit 1
          fi
          
          echo "GitHub CLI authenticated successfully"
          echo ""
          
          # Update secrets using the repository context
          echo "$VM_IP" | gh secret set PUBLIC_IP --env $ENV --repo "$GITHUB_REPOSITORY"
          echo "$VM_IP" | gh secret set VM_PUBLIC_IP --env $ENV --repo "$GITHUB_REPOSITORY"
          echo "$VM_IP:8443" | gh secret set NIFI_WEB_PROXY_HOST --env $ENV --repo "$GITHUB_REPOSITORY"
          echo "https://$VM_IP:8443" | gh secret set NIFI_URL --env $ENV --repo "$GITHUB_REPOSITORY"
          echo "http://$VM_IP:18080" | gh secret set REGISTRY_URL --env $ENV --repo "$GITHUB_REPOSITORY"
          
          echo ""
          echo "Dynamic secrets updated for $ENV environment"      
      
      - name: Set Provision Status
        id: provision_status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "Development provisioning completed successfully"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "Development provisioning failed"
          fi

  summary:
    name: Provisioning Summary
    needs: [
      determine-environments, 
      check-infrastructure, 
      provision-development,
      provision-staging,
      provision-production
    ]
    if: always()
    runs-on: ubuntu-22.04
    steps:
      - name: Display Summary
        run: |
          echo ""
          echo "=========================================="
          echo " MULTI-ENVIRONMENT PROVISIONING SUMMARY"
          echo "=========================================="
          echo ""
          echo "Target: ${{ needs.determine-environments.outputs.environment_list }}"
          echo "Wait Time Between Envs: ${{ github.event.inputs.wait_time }}s"
          echo ""
          echo "Status:"
          echo "  Environment Detection: ${{ needs.determine-environments.result }}"
          echo "  Infrastructure Check: ${{ needs.check-infrastructure.result }}"
          
          # Check individual environment results
          DEV_STATUS="${{ needs.provision-development.result }}"
          STAGING_STATUS="${{ needs.provision-staging.result }}"
          PROD_STATUS="${{ needs.provision-production.result }}"
          
          SUCCESS_COUNT=0
          TOTAL_COUNT=0
          
          echo ""
          echo "Environment Results:"
          
          if [[ "${{ needs.determine-environments.outputs.environment_list }}" == *"development"* ]]; then
            TOTAL_COUNT=$((TOTAL_COUNT + 1))
            if [ "$DEV_STATUS" = "success" ]; then
              echo "  Development: Success"
              echo "     IP: ${{ needs.provision-development.outputs.vm_ip }}"
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            elif [ "$DEV_STATUS" = "skipped" ]; then
              echo "Development: Skipped"
            else
              echo "Development: Failed"
            fi
          fi
          
          if [[ "${{ needs.determine-environments.outputs.environment_list }}" == *"staging"* ]]; then
            TOTAL_COUNT=$((TOTAL_COUNT + 1))
            if [ "$STAGING_STATUS" = "success" ]; then
              echo "  Staging: Success"
              echo "     IP: ${{ needs.provision-staging.outputs.vm_ip }}"
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            elif [ "$STAGING_STATUS" = "skipped" ]; then
              echo "Staging: Skipped"
            else
              echo "Staging: Failed"
            fi
          fi
          
          if [[ "${{ needs.determine-environments.outputs.environment_list }}" == *"production"* ]]; then
            TOTAL_COUNT=$((TOTAL_COUNT + 1))
            if [ "$PROD_STATUS" = "success" ]; then
              echo "  Production: Success"
              echo "IP: ${{ needs.provision-production.outputs.vm_ip }}"
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            elif [ "$PROD_STATUS" = "skipped" ]; then
              echo "Production: Skipped"
            else
              echo "Production: Failed"
            fi
          fi
          
          echo ""
          echo "Summary: $SUCCESS_COUNT/$TOTAL_COUNT environments provisioned successfully"
          echo ""
          
          if [ "$SUCCESS_COUNT" -eq "$TOTAL_COUNT" ] && [ "$TOTAL_COUNT" -gt 0 ]; then
            echo "All requested environments provisioned successfully!"
            echo ""
            echo "Next steps:"
            echo "  1. Deploy applications using deployment workflows"
            echo "  2. Access VMs via environment-specific secrets"
            echo "  3. Monitor deployments in GitHub Actions"
          elif [ "$SUCCESS_COUNT" -eq 0 ]; then
            echo "No environments were provisioned successfully"
            echo "Check the logs above for details on what failed."
          else
            echo "Partial success: Some environments failed"
            echo "Check the logs above for details on failed environments."
          fi
          
          echo ""
          echo "=========================================="

  wait-after-development:
    name: Wait After Development
    needs: [determine-environments, provision-development]
    if: |
      always() &&
      needs.provision-development.result == 'success' &&
      needs.determine-environments.outputs.is_multiple == 'true'
    runs-on: ubuntu-22.04
    steps:
      - name: Wait Between Environments
        run: |
          WAIT_TIME="${{ github.event.inputs.wait_time }}"
          echo "Waiting ${WAIT_TIME} seconds before provisioning next environment..."
          sleep $WAIT_TIME
          echo "Wait complete"

  provision-staging:
    name: Provision VM (staging)
    needs: [determine-environments, check-infrastructure, setup-secrets, wait-after-development]
    if: |
      always() &&
      needs.determine-environments.result == 'success' &&
      needs.setup-secrets.result == 'success' &&
      contains(fromJson(needs.determine-environments.outputs.environments), 'staging') &&
      (needs.wait-after-development.result == 'success' || needs.wait-after-development.result == 'skipped')
    runs-on: ubuntu-22.04
    environment: staging
    outputs:
      success: ${{ steps.provision_status.outputs.success }}
      vm_ip: ${{ steps.get_ip.outputs.ip }}
    steps:      
      - name: Checkout code
        uses: actions/checkout@v5
        
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.ARM_CLIENT_ID }}",
              "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.ARM_TENANT_ID }}"
            }
            
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~> 1.5"
          terraform_wrapper: false
          
      - name: Terraform Init
        working-directory: ./azure-vm-terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        run: terraform init -input=false
        
      - name: Terraform Validate
        working-directory: ./azure-vm-terraform
        run: terraform validate
        
      - name: Terraform Plan
        working-directory: ./azure-vm-terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          TF_VAR_environment: staging
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_azure_subscription_id: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        run: terraform plan -var-file="staging.tfvars" -out=tfplan -input=false
        
      - name: Terraform Apply
        working-directory: ./azure-vm-terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          TF_VAR_environment: staging
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_azure_subscription_id: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        run: terraform apply -auto-approve tfplan
        
      - name: Get VM IP Address
        id: get_ip
        working-directory: ./azure-vm-terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        run: |
          VM_IP=$(terraform output -raw vm_public_ip)
          echo "ip=$VM_IP" >> $GITHUB_OUTPUT
          echo "VM Public IP: $VM_IP"
          
      - name: Wait for VM to be ready
        run: |
          echo "Waiting for VM to complete initialization..."
          sleep 45
          echo "VM should be ready"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ steps.get_ip.outputs.ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          
      - name: Configure Docker Permissions
        run: |
          echo "Configuring Docker permissions for user..."
          
          MAX_RETRIES=5
          for i in $(seq 1 $MAX_RETRIES); do
            if ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 \
              ${{ secrets.VM_USERNAME }}@${{ steps.get_ip.outputs.ip }} \
              "sudo usermod -aG docker ${{ secrets.VM_USERNAME }}"; then
              echo "User added to docker group"
              break
            fi
            
            if [ $i -eq $MAX_RETRIES ]; then
              echo "Warning: Failed to configure docker permissions"
            else
              echo "Retry $i/$MAX_RETRIES..."
              sleep 10
            fi
          done
          
          echo ""
          echo "Docker group membership will take effect on next SSH login"
          
      - name: Cleanup SSH Keys
        if: always()
        run: rm -f ~/.ssh/deploy_key

      - name: Update IP-based Secrets
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          ENV="staging"
          VM_IP="${{ steps.get_ip.outputs.ip }}"
          
          echo "Updating dynamic secrets for $ENV with VM IP: $VM_IP"
          
          echo "$VM_IP" | gh secret set PUBLIC_IP --env $ENV
          echo "$VM_IP" | gh secret set VM_PUBLIC_IP --env $ENV
          echo "$VM_IP:8443" | gh secret set NIFI_WEB_PROXY_HOST --env $ENV
          echo "https://$VM_IP:8443" | gh secret set NIFI_URL --env $ENV
          echo "http://$VM_IP:18080" | gh secret set REGISTRY_URL --env $ENV
          
          echo "Dynamic secrets updated for $ENV environment"
      
      - name: Set Provision Status
        id: provision_status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "Staging provisioning completed successfully"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "Staging provisioning failed"
          fi

  wait-after-staging:
    name: Wait After Staging
    needs: [determine-environments, provision-staging]
    if: |
      always() &&
      needs.provision-staging.result == 'success' &&
      needs.determine-environments.outputs.is_multiple == 'true'
    runs-on: ubuntu-22.04
    steps:
      - name: Wait Between Environments
        run: |
          WAIT_TIME="${{ github.event.inputs.wait_time }}"
          echo "Waiting ${WAIT_TIME} seconds before provisioning next environment..."
          sleep $WAIT_TIME
          echo "Wait complete"

  provision-production:
    name: Provision VM (production)
    needs: [determine-environments, check-infrastructure, setup-secrets, wait-after-staging]
    if: |
      always() &&
      needs.determine-environments.result == 'success' &&
      needs.setup-secrets.result == 'success' &&
      contains(fromJson(needs.determine-environments.outputs.environments), 'production') &&
      (needs.wait-after-staging.result == 'success' || needs.wait-after-staging.result == 'skipped')
    runs-on: ubuntu-22.04
    environment: production
    outputs:
      success: ${{ steps.provision_status.outputs.success }}
      vm_ip: ${{ steps.get_ip.outputs.ip }}
    steps:      
      - name: Checkout code
        uses: actions/checkout@v5
        
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.ARM_CLIENT_ID }}",
              "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.ARM_TENANT_ID }}"
            }
            
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~> 1.5"
          terraform_wrapper: false
          
      - name: Terraform Init
        working-directory: ./azure-vm-terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        run: terraform init -input=false
        
      - name: Terraform Validate
        working-directory: ./azure-vm-terraform
        run: terraform validate
        
      - name: Terraform Plan
        working-directory: ./azure-vm-terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          TF_VAR_environment: production
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_azure_subscription_id: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        run: terraform plan -var-file="production.tfvars" -out=tfplan -input=false
        
      - name: Terraform Apply
        working-directory: ./azure-vm-terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          TF_VAR_environment: production
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_azure_subscription_id: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        run: terraform apply -auto-approve tfplan
        
      - name: Get VM IP Address
        id: get_ip
        working-directory: ./azure-vm-terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        run: |
          VM_IP=$(terraform output -raw vm_public_ip)
          echo "ip=$VM_IP" >> $GITHUB_OUTPUT
          echo "VM Public IP: $VM_IP"
          
      - name: Wait for VM to be ready
        run: |
          echo "Waiting for VM to complete initialization..."
          sleep 45
          echo "VM should be ready"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ steps.get_ip.outputs.ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          
      - name: Configure Docker Permissions
        run: |
          echo "Configuring Docker permissions for user..."
          
          MAX_RETRIES=5
          for i in $(seq 1 $MAX_RETRIES); do
            if ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 \
              ${{ secrets.VM_USERNAME }}@${{ steps.get_ip.outputs.ip }} \
              "sudo usermod -aG docker ${{ secrets.VM_USERNAME }}"; then
              echo "User added to docker group"
              break
            fi
            
            if [ $i -eq $MAX_RETRIES ]; then
              echo "Warning: Failed to configure docker permissions"
            else
              echo "Retry $i/$MAX_RETRIES..."
              sleep 10
            fi
          done
          
          echo ""
          echo "Docker group membership will take effect on next SSH login"
          
      - name: Cleanup SSH Keys
        if: always()
        run: rm -f ~/.ssh/deploy_key

      - name: Update IP-based Secrets
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          ENV="production"
          VM_IP="${{ steps.get_ip.outputs.ip }}"
          
          echo "Updating dynamic secrets for $ENV with VM IP: $VM_IP"
          
          # Verify GH_TOKEN is set
          if [ -z "$GH_TOKEN" ]; then
            echo "ERROR: GH_TOKEN is not set"
            echo "Please ensure GH_TOKEN is configured in repository secrets"
            exit 1
          fi
          
          # Verify GitHub CLI authentication
          if ! gh auth status 2>&1 | grep -q "Logged in"; then
            echo "ERROR: GitHub CLI authentication failed"
            echo "Token may be invalid or expired"
            exit 1
          fi
          
          echo "GitHub CLI authenticated successfully"
          echo ""
          
          # Update secrets using the repository context
          echo "$VM_IP" | gh secret set PUBLIC_IP --env $ENV --repo "$GITHUB_REPOSITORY"
          echo "$VM_IP" | gh secret set VM_PUBLIC_IP --env $ENV --repo "$GITHUB_REPOSITORY"
          echo "$VM_IP:8443" | gh secret set NIFI_WEB_PROXY_HOST --env $ENV --repo "$GITHUB_REPOSITORY"
          echo "https://$VM_IP:8443" | gh secret set NIFI_URL --env $ENV --repo "$GITHUB_REPOSITORY"
          echo "http://$VM_IP:18080" | gh secret set REGISTRY_URL --env $ENV --repo "$GITHUB_REPOSITORY"
          
          echo ""
          echo "Dynamic secrets updated for $ENV environment"      
      
      - name: Set Provision Status
        id: provision_status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "production provisioning completed successfully"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "production provisioning failed"
          fi
