name: Destroy Infrastructure

on:
  workflow_dispatch:
    inputs:
      environments:
        description: 'Environment(s) to destroy (comma-separated: development,staging,production)'
        required: true
        type: string
        default: 'development'
      confirm_destruction:
        description: 'Type "DESTROY" to confirm infrastructure destruction'
        required: true
        type: string
      backup_before_destroy:
        description: 'Create backup before destroying?'
        required: true
        type: boolean
        default: true
      cleanup_secrets:
        description: 'Remove GitHub dynamic secrets after destroy?'
        required: true
        type: boolean
        default: false
      wait_time:
        description: 'Wait time between environments (seconds)'
        required: false
        type: number
        default: 30

permissions:
  contents: read
  actions: read

jobs:
  determine-environments:
    name: Determine Target Environments
    runs-on: ubuntu-22.04
    outputs:
      environments: ${{ steps.set_envs.outputs.environments }}
      environment_list: ${{ steps.set_envs.outputs.environment_list }}
    steps:
      - name: Parse and Validate Environments
        id: set_envs
        run: |
          INPUT="${{ github.event.inputs.environments }}"
          INPUT=$(echo "$INPUT" | tr -d ' ' | tr '[:upper:]' '[:lower:]')
          IFS=',' read -ra ENV_ARRAY <<< "$INPUT"
          
          VALID_ENVS=()
          INVALID_ENVS=()
          
          for env in "${ENV_ARRAY[@]}"; do
            case "$env" in
              development|staging|production)
                [[ ! " ${VALID_ENVS[@]} " =~ " ${env} " ]] && VALID_ENVS+=("$env")
                ;;
              *)
                INVALID_ENVS+=("$env")
                ;;
            esac
          done
          
          [ ${#INVALID_ENVS[@]} -gt 0 ] && echo "Invalid: ${INVALID_ENVS[*]}" && exit 1
          [ ${#VALID_ENVS[@]} -eq 0 ] && echo "No valid environments" && exit 1
          
          JSON_ARRAY=$(printf '%s\n' "${VALID_ENVS[@]}" | jq -R . | jq -s .)
          ENV_LIST=$(IFS=','; echo "${VALID_ENVS[*]}")
          
          echo "environments=$JSON_ARRAY" >> $GITHUB_OUTPUT
          echo "environment_list=$ENV_LIST" >> $GITHUB_OUTPUT
          
          [ ${#VALID_ENVS[@]} -gt 1 ] && echo "Destroying ${#VALID_ENVS[@]} environments: $ENV_LIST" || echo "Destroying: ${VALID_ENVS[0]}"
          
  validate-and-destroy:
    name: Destroy ${{ matrix.environment }}
    needs: determine-environments
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        environment: ${{ fromJson(needs.determine-environments.outputs.environments) }}
      max-parallel: 1
      fail-fast: false
    environment: ${{ matrix.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        
      - name: Validate Confirmation
        run: |
          if [ "${{ github.event.inputs.confirm_destruction }}" != "DESTROY" ]; then
            echo "ERROR: You must type exactly: DESTROY"
            echo "You typed: ${{ github.event.inputs.confirm_destruction }}"
            exit 1
          fi
          echo "Destruction confirmed for ${{ matrix.environment }}"
          
      - name: Get Environment Configuration
        id: env_config
        run: |
          ENV="${{ matrix.environment }}"
          RG_SUFFIX="${ENV/development/dev}"
          
          echo "rg=rg-nificicd-g1p2-$RG_SUFFIX" >> $GITHUB_OUTPUT
          echo "vm_name=vm-nifi-$ENV" >> $GITHUB_OUTPUT
          echo "backup_dir=$ENV-backups" >> $GITHUB_OUTPUT
          echo "compose_file=compose.$ENV.yml" >> $GITHUB_OUTPUT
          echo "env_file=.env.$ENV" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: |
            {
              "clientId": "${{ secrets.ARM_CLIENT_ID }}",
              "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.ARM_TENANT_ID }}"
            }
            
      - name: Check Infrastructure Status
        id: check_infra
        run: |
          RG="${{ steps.env_config.outputs.rg }}"
          VM_NAME="${{ steps.env_config.outputs.vm_name }}"
          
          if az group exists --name $RG | grep -q "true"; then
            if az vm show --resource-group $RG --name $VM_NAME &>/dev/null; then
              VM_IP=$(az vm show -d --resource-group $RG --name $VM_NAME --query publicIps -o tsv)
              echo "vm_exists=true" >> $GITHUB_OUTPUT
              echo "vm_ip=$VM_IP" >> $GITHUB_OUTPUT
              echo "VM found: $VM_IP"
              echo -e "\nResources to be deleted:"
              az resource list --resource-group $RG --output table || true
            else
              echo "vm_exists=false" >> $GITHUB_OUTPUT
              echo "VM not found"
            fi
            echo "rg_exists=true" >> $GITHUB_OUTPUT
          else
            echo "vm_exists=false" >> $GITHUB_OUTPUT
            echo "rg_exists=false" >> $GITHUB_OUTPUT
            echo "Resource group does not exist - nothing to destroy"
          fi

      - name: Create Final Backup
        id: backup
        if: github.event.inputs.backup_before_destroy == 'true' && steps.check_infra.outputs.vm_exists == 'true'
        run: |
          echo "Creating final backup..."
          
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          ssh-keyscan -H ${{ steps.check_infra.outputs.vm_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          
          BACKUP_NAME="final-backup-$(date +%Y%m%d_%H%M%S)"
          
          # Create backup script
          cat > /tmp/backup.sh <<'BACKUP_SCRIPT'
          #!/bin/bash
          set -e
          BACKUP_NAME="$1"
          BACKUP_DIR="$2"
          COMPOSE_FILE="$3"
          ENV_FILE="$4"
          BACKUP_PATH="$HOME/$BACKUP_DIR/$BACKUP_NAME"
          
          echo "Creating backup at: $BACKUP_PATH"
          mkdir -p "$BACKUP_PATH"
          
          if [ ! -d ~/nificicd-g1p2 ]; then
            echo "No deployment found - creating minimal backup"
            cat > "$BACKUP_PATH/backup-info.txt" <<INFO
          Backup Date: $(date)
          Environment: ${{ matrix.environment }}
          Reason: Infrastructure destruction
          Status: No deployment found
          INFO
            cd "$HOME/$BACKUP_DIR"
            tar czf "$BACKUP_NAME.tar.gz" "$BACKUP_NAME"
            rm -rf "$BACKUP_NAME"
            exit 0
          fi
          
          cd ~/nificicd-g1p2
          
          # Backup configuration files
          echo "Backing up configuration..."
          for item in flows registry_data "$ENV_FILE" "$COMPOSE_FILE" config scripts; do
            [ -e "$item" ] && cp -r "$item" "$BACKUP_PATH/" 2>/dev/null && echo "$item" || true
          done
          
          # Backup running container data
          if command -v docker &>/dev/null && [ -f "$COMPOSE_FILE" ]; then
            if sudo docker compose -f "$COMPOSE_FILE" ps -q nifi 2>/dev/null | grep -q .; then
              echo "Backing up NiFi container data..."
              sudo docker compose -f "$COMPOSE_FILE" exec -T nifi tar czf - /opt/nifi/nifi-current/conf 2>/dev/null > "$BACKUP_PATH/nifi-conf.tar.gz" && echo "  ✅ nifi-conf.tar.gz" || true
              sudo docker compose -f "$COMPOSE_FILE" exec -T nifi tar czf - /opt/nifi/nifi-current/logs 2>/dev/null > "$BACKUP_PATH/nifi-logs.tar.gz" && echo "  ✅ nifi-logs.tar.gz" || true
            fi
          fi
          
          # Create backup info
          cat > "$BACKUP_PATH/backup-info.txt" <<INFO
          Backup Date: $(date)
          Environment: ${{ matrix.environment }}
          Reason: Infrastructure destruction
          VM IP: $(curl -s ifconfig.me 2>/dev/null || echo "unknown")
          Hostname: $(hostname)
          INFO
          
          # Compress backup
          cd "$HOME/$BACKUP_DIR"
          tar czf "$BACKUP_NAME.tar.gz" "$BACKUP_NAME"
          rm -rf "$BACKUP_NAME"
          
          [ -f "$BACKUP_NAME.tar.gz" ] && echo "Backup created: $(du -h "$BACKUP_NAME.tar.gz" | cut -f1)" || exit 1
          BACKUP_SCRIPT
          
          # Execute backup on VM
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
            ${{ secrets.VM_USERNAME }}@${{ steps.check_infra.outputs.vm_ip }} \
            "bash -s '$BACKUP_NAME' '${{ steps.env_config.outputs.backup_dir }}' '${{ steps.env_config.outputs.compose_file }}' '${{ steps.env_config.outputs.env_file }}'" < /tmp/backup.sh
          
          # Download backup
          echo -e "\nDownloading backup..."
          if scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
            ${{ secrets.VM_USERNAME }}@${{ steps.check_infra.outputs.vm_ip }}:~/${{ steps.env_config.outputs.backup_dir }}/$BACKUP_NAME.tar.gz \
            ./final-backup.tar.gz 2>&1 && [ -f ./final-backup.tar.gz ]; then
            echo "Backup downloaded: $(du -h ./final-backup.tar.gz | cut -f1)"
            echo "backup_created=true" >> $GITHUB_OUTPUT
          else
            echo "Backup remains on VM at: ~/${{ steps.env_config.outputs.backup_dir }}/$BACKUP_NAME.tar.gz"
            echo "backup_created=false" >> $GITHUB_OUTPUT
          fi
          
          rm -f ~/.ssh/deploy_key
          
      - name: Upload Backup Artifact
        if: github.event.inputs.backup_before_destroy == 'true' && steps.backup.outputs.backup_created == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: final-${{ matrix.environment }}-backup-${{ github.run_number }}
          path: final-backup.tar.gz
          retention-days: 90
        continue-on-error: true

      - name: Delete Resource Group
        if: steps.check_infra.outputs.rg_exists == 'true'
        run: |
          RG="${{ steps.env_config.outputs.rg }}"
          
          echo -e "\nDeleting resource group: $RG"
          az group delete --name $RG --yes --no-wait
          echo "Deletion initiated"
          
          echo -e "\nWaiting for deletion to complete..."
          for i in {1..60}; do
            if ! az group exists --name $RG | grep -q "true"; then
              echo "Resource group deleted: $RG"
              exit 0
            fi
            echo "  Checking... ($i/60)"
            sleep 10
          done
          
          echo "Deletion in progress - monitor at: https://portal.azure.com"

      - name: Clean Up Dynamic Secrets
        if: github.event.inputs.cleanup_secrets == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          if [ -z "$GH_TOKEN" ] || ! gh auth status &>/dev/null; then
            cat <<MSG
          
          Cannot clean up secrets automatically
          
          Please manually remove from:
            Settings → Environments → ${{ matrix.environment }}
          
          Dynamic secrets to remove:
            • VM_PUBLIC_IP
            • NIFI_WEB_PROXY_HOST
            • NIFI_URL
            • REGISTRY_URL
          
          MSG
            exit 0
          fi
          
          ENV="${{ matrix.environment }}"
          echo "Cleaning up dynamic secrets from $ENV..."
          
          for secret in VM_PUBLIC_IP NIFI_WEB_PROXY_HOST NIFI_URL REGISTRY_URL; do
            gh secret delete "$secret" --env $ENV 2>/dev/null && echo "Removed: $secret" || echo "  Skipped: $secret"
          done
          
          echo -e "\nDynamic secrets cleaned from $ENV environment"

      - name: Wait Between Environments
        if: success()
        run: |
          ENVIRONMENTS='${{ needs.determine-environments.outputs.environments }}'
          CURRENT_ENV="${{ matrix.environment }}"
          LAST_ENV=$(echo "$ENVIRONMENTS" | jq -r '.[-1]')
          
          [ "$CURRENT_ENV" != "$LAST_ENV" ] && echo "Waiting ${{ github.event.inputs.wait_time }}s..." && sleep ${{ github.event.inputs.wait_time }}

      - name: Destruction Summary
        if: always()
        run: |
          cat <<SUMMARY
          
          ======================================
           ${{ matrix.environment }} DESTRUCTION SUMMARY
          ======================================
          
          VM: ${{ steps.env_config.outputs.vm_name }}
          Resource Group: ${{ steps.env_config.outputs.rg }}
          Status: ${{ job.status }}
          
          Backup: $([ "${{ steps.backup.outputs.backup_created }}" = "true" ] && echo "Created and uploaded (90 days)" || echo "Skipped or failed")
          Secrets: $([ "${{ github.event.inputs.cleanup_secrets }}" = "true" ] && echo "Dynamic secrets removed" || echo "Retained")
          
          ======================================
          
          SUMMARY

  final-summary:
    name: Destruction Summary
    needs: [determine-environments, validate-and-destroy]
    if: always()
    runs-on: ubuntu-22.04
    steps:
      - name: Display Final Summary
        run: |
          STATUS="${{ needs.validate-and-destroy.result }}"
          
          cat <<SUMMARY
          
          ======================================
            INFRASTRUCTURE DESTRUCTION SUMMARY
          ======================================
          
          Environments: ${{ needs.determine-environments.outputs.environment_list }}
          Status: $STATUS
          
          SUMMARY
          
          if [ "$STATUS" = "success" ]; then
            cat <<SUCCESS
          All environments successfully destroyed
          
          Destroyed resources per environment:
            • Virtual machines
            • Network interfaces
            • Public IP addresses
            • Network security groups
            • Virtual networks
            • Storage accounts
            • All NiFi data and configurations
          
          SUCCESS
            
            [ "${{ github.event.inputs.backup_before_destroy }}" = "true" ] && cat <<BACKUP
          Backups:
            • Available in Actions → Artifacts
            • Retention: 90 days
            • Download anytime to restore
          
          BACKUP
            
            [ "${{ github.event.inputs.cleanup_secrets }}" = "true" ] && cat <<SECRETS
          Secrets:
            • Dynamic secrets removed
            • Static secrets retained for redeployment
          
          SECRETS
            
            cat <<REDEPLOY
          To redeploy:
            • Run 'Provision Infrastructure' workflow
            • Push to: develop/staging/main branches
            • VMs will be auto-provisioned and configured
          
          REDEPLOY
          else
            cat <<FAILURE
          Destruction encountered issues
          
          Manual cleanup commands:
          FAILURE
            
            for env in $(echo "${{ needs.determine-environments.outputs.environment_list }}" | tr ',' ' '); do
              RG_SUFFIX="${env/development/dev}"
              echo "  $env: az group delete --name rg-nificicd-g1p2-$RG_SUFFIX --yes"
            done
            
            echo -e "\nCheck Azure Portal: https://portal.azure.com\n"
          fi